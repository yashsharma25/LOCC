<!DOCTYPE html>
<html>
<head>
  <title>Quantum entanglement visualization</title>

<script type="text/javascript" src="d3.js"></script>

<script type="module">
//https://cdn.jsdelivr.net/npm/d3@7

let width=800,height=800;
let stateData;

let forceNode = d3.forceManyBody().strength(-400);
let forceLink = d3.forceLink([]).id((x) => x.id).distance(500);

let simulation = d3.forceSimulation()
    .force("link", forceLink)
    .force("charge", forceNode)
    .force("center",  d3.forceCenter())
    .on("tick", tick);

let svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [-width / 2, -height / 2, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

let linkWidth=48;
let minPeriod=1500,addedPeriod=0;
let timestep=0,time=0,maxtimestep=100;
let linkTypes={
  outline:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#eee")},
    update:(selection)=>{selection.attr("stroke-width",(d)=>1.05*linkWidth)}
  },
  max:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#adf")},
    update:(selection)=>{selection.attr("stroke-width",(d)=>{(stateData.is_changing)?(d.max[timestep]*linkWidth):(d.max*linkWidth)})},
    tick:(selection)=>{
      if(stateData&&stateData.is_changing){selection.attr("stroke-width",(d)=>d.max[timestep]*linkWidth)}
    }
  },
  min:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#35a")},
    update:(selection)=>{
      selection.attr("stroke-width",(d)=>{stateData.is_changing?(d.min[timestep]*linkWidth):(d.min*linkWidth)});
      if(stateData&&(!stateData.is_changing)){
        selection.each((d)=>{
          let period=1000,offset=1000*Math.random();
          function repeat(period,offset) {
            selection
            .attr("stroke-width",(d)=>d.min*linkWidth)
            .transition()
            .duration((d,i)=>i*addedPeriod+minPeriod)
            .attr("stroke-width",(d)=>d.max*linkWidth)
            .transition()
            .duration((d,i)=>i*addedPeriod+minPeriod)
            .attr("stroke-width",(d)=>d.min*linkWidth)
            .on("end", repeat);
          };
          //repeat(period,offset);
      });


      }
    },
    tick:(selection)=>{
      if(stateData&&stateData.is_changing){selection.attr("stroke-width",(d)=>d.min[timestep]*linkWidth)}
    }
  }

}

for(let type in linkTypes){
  console.log(type);
  let g=svg.append("g")
      .attr("stroke-width",1)
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6)
      .attr("stroke-linecap", "round");

    linkTypes[type].selection=g.selectAll("line");
    if(linkTypes[type].init){
      linkTypes[type].init(g);
    }

}


  let node = svg.append("g")
      .attr("stroke-width", 3)
    .selectAll("circle");


function tick() {
  for(let type in linkTypes){
    linkTypes[type].selection
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

    if(linkTypes[type].tick){
      linkTypes[type].tick(linkTypes[type].selection);
    }
    time+=0.09;if(timestep>maxtimestep){time=-maxtimestep-0.1;}
    timestep=Math.floor(Math.abs(time));

  }

  node
    .attr("cx", d => d.x)
    .attr("cy", d => d.y);
}
function drag(simulation) {
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  return d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended);
}

function setData(data){
  console.log(data);

  simulation.nodes(data.nodes);
  forceLink.links(data.links);
  for(let type in linkTypes){
    linkTypes[type].selection=linkTypes[type].selection.data(data.links).join("line");
    linkTypes[type].update(linkTypes[type].selection);
  }

let nodeRadius=18;
  node = node.data(data.nodes, function(d) { return d.id;}).join("circle")
    .attr("r", nodeRadius)
    .call(drag(simulation));
    ;

  simulation.restart();
}


function initState(data){
  console.log(data)
  //dims:qudit dims,parties:parties(currently one qudit per party),state:state vector
  let n=data.dims.length;
  let parties=n;
  stateData=data;
  if(data.steps)maxtimestep=data.steps;
  timestep=0;time=0;
  let graph={nodes:[],links:[]};
  for(let i=0;i<n;i++){graph.nodes.push( {id:i,index:i,party:i})}
  for(let key in data.e_stats){
    let st=key.split(",").map((x)=>parseInt(x.trim()));
    let value=data.e_stats[key];
    graph.links.push({source:graph.nodes[st[0]],target:graph.nodes[st[1]],max:value.max,min:value.min});
  }
  /*for(let i=0;i<n;i++){
    for(let j=0;j<i;j++){
      graph.links.push({source:i,target:j});
    }
  }*/
  setData(graph);

}

d3.json("state.json").then(initState);


</script>

</head>

<body>




</body>


</html>
