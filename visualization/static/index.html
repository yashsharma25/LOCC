<!DOCTYPE html>
<html>
<head>
  <title>Quantum entanglement visualization</title>

<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/d3@7"></script>

<script type="module">
//d3.js
//https://cdn.jsdelivr.net/npm/d3@7

let width=800,height=800;
let stateData;let possibleStates=[];

let forceNode = d3.forceManyBody().strength(-400);
let forceLink = d3.forceLink([]).id((x) => x.id).distance(500);

let simulation = d3.forceSimulation()
    .alphaTarget(0.2)
    .force("link", forceLink)
    .force("charge", forceNode)
    .force("center",  d3.forceCenter())
    .on("tick", tick);

let svg = d3.select("body").append("svg")
        .attr("width", width)
        .attr("height", height)
        .attr("viewBox", [-width / 2, -height / 2, width, height])
        .attr("style", "max-width: 100%; height: auto; height: intrinsic;");

let titleBar = d3.select("body").append("div").style("position","absolute").style("top","0").style("width","100%")
.style("text-align","center");
let titleText=titleBar.append("p");//titleText.style("font-size",)

let nodeRadius=20;
let linkWidth=48;
let linkAnimPeriod=2000,minPeriod=1000,addedPeriod=1000;
let timestep=0,time=0,maxtimestep=100;

let nodeTypes={
  node:{
    type:"circle",
    init:(g)=>{
      g.attr("stroke-width", 3)
      .style('stroke', '#def')
      .style('fill', 'none')
      ;
    },
    update:(selection)=>{
          selection
          .attr("r", (d)=>(d.dim?Math.log2(d.dim):1)*nodeRadius)
          .call(drag(simulation));
          ;
    },
    tick:(selection)=>{
      selection
        .attr("cx", d => d.x)
        .attr("cy", d => d.y);
    }
  },
  outcome:{
    type:"circle",
    init:(g)=>{
      g.attr("stroke-width", 2);
    },
    update:(selection)=>{
          selection
          .attr("r", (d)=>{
            let result=possibleStates[0].values[d.id];
            if(result==0) return nodeRadius/2-2;
            else return Math.log2(result)*nodeRadius })
          //.call(drag(simulation));
          ;
          //let obj={prob:prob,values:values,amplitude:x,phase:Math.atan(x.im/x.re)}

    },
    tick:(selection)=>{
      selection
        .attr("cx", d => d.x)
        .attr("cy", d => d.y)
        .attr("r", (d)=>{
          let stateid=Math.min(Math.floor(Math.abs(timestep-1)/100),possibleStates.length-1);
          let result=possibleStates[stateid].values[d.id];
          if(result==0) return nodeRadius/2-2;
          else return (Math.log2(result)+1)*nodeRadius })
        //.call(drag(simulation));
        ;
    }
  },
  label:{
    type:"text",
    init:(g)=>{
      g.text(function(d) {
        return d&&d.id;
      })
      //.style('stroke', '#fff')
      .style('fill', '#fff')
      .style('font-size', '16px')
      .attr('x', 6)
      .attr('y', 3);
    },
    update:(selection)=>{
      selection.text(function(d) {
        return d.id;
      });

    },
    tick:(selection)=>{
      selection
        .attr("x", d => d.x-3)
        .attr("y", d => d.y+3);
    }
  }
}
let linkTypes={
  outline:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#eee")},
    update:(selection)=>{selection.attr("stroke-width",(d)=>1.05*linkWidth)}
  },
  max:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#adf")},
    update:(selection)=>{
      if(stateData){
        if(stateData.is_changing){
          selection.attr("stroke-width",(d)=>d.max[timestep]*linkWidth)
        }
        else {
          selection.attr("stroke-width",(d)=>d.max*linkWidth)
        }
      }
    },

    tick:(selection)=>{
      if(stateData&&stateData.is_changing){selection.attr("stroke-width",(d)=>d.max[timestep]*linkWidth)}
    }
  },
  min:{
    init:(g)=>{g.attr("stroke-opacity", 0.9).attr("stroke", "#35a")},
    update:(selection)=>{
      selection.attr("stroke-width",(d)=>{(stateData.is_changing)?(d.min[timestep]*linkWidth):(d.min*linkWidth)});
      if(stateData&&(!stateData.is_changing)){
          //variant: synchronized animation with the same period for all
          /*
          function repeat() {
            selection
            .attr("stroke-width",(d)=>d.min*linkWidth)
            .transition()
            .duration(linkAnimPeriod)
            .attr("stroke-width",(d)=>d.max*linkWidth)
            .transition()
            .duration(linkAnimPeriod)
            .attr("stroke-width",(d)=>d.min*linkWidth)
            .on("end", repeat);
          }
          repeat();
          */

          //variant: each edge has its own period and offset, which are random

          selection.each(function my(d,i){
            let that=this;//need to be a named function to have this??
            let period=minPeriod+addedPeriod*Math.random(),offset=period*Math.random();
            function repeat() {
              console.log(d,i,that);
              d3.select(that)
              //.selectAll(".line")
              .attr("stroke-width",(d)=>d.min*linkWidth)
              .transition()
              .duration(period)
              .attr("stroke-width",(d)=>d.max*linkWidth)
              .transition()
              .duration(period)
              .attr("stroke-width",(d)=>d.min*linkWidth)
              .on("end", repeat);
            }
            setTimeout(repeat,offset);
          });


      }
    },
    tick:(selection)=>{
      if(stateData&&stateData.is_changing){selection.attr("stroke-width",(d)=>d.min[timestep]*linkWidth)}
    }
  }

}



for(let type in linkTypes){
  console.log(type);
  let g=svg.append("g")
      .attr("stroke-width",1)
      .attr("stroke", "#999")
      .attr("stroke-opacity", 0.6)
      .attr("stroke-linecap", "round");

    linkTypes[type].selection=g.selectAll("line");
    if(linkTypes[type].init){
      linkTypes[type].init(g);
    }

}

for(let type in nodeTypes){
  console.log(type);
  let elemType=nodeTypes[type].type;
  let g=svg.append("g");


    nodeTypes[type].selection=g.selectAll(elemType);
    if(nodeTypes[type].init){
      nodeTypes[type].init(g);
    }

}



function tick() {
  for(let type in linkTypes){
    linkTypes[type].selection
    .attr("x1", d => d.source.x)
    .attr("y1", d => d.source.y)
    .attr("x2", d => d.target.x)
    .attr("y2", d => d.target.y);

    if(linkTypes[type].tick){
      linkTypes[type].tick(linkTypes[type].selection);
    }


  }
  for(let type in nodeTypes){
    if(nodeTypes[type].tick){
      nodeTypes[type].tick(nodeTypes[type].selection);
    }
  }


  time+=0.087;if(time>=maxtimestep){time=-maxtimestep+0.01;}
  timestep=Math.floor(Math.abs(time));

}
function drag(simulation) {
  function dragstarted(event) {
    if (!event.active) simulation.alphaTarget(0.3).restart();
    event.subject.fx = event.subject.x;
    event.subject.fy = event.subject.y;
  }

  function dragged(event) {
    event.subject.fx = event.x;
    event.subject.fy = event.y;
  }

  function dragended(event) {
    if (!event.active) simulation.alphaTarget(0);
    event.subject.fx = null;
    event.subject.fy = null;
  }

  return d3.drag()
    .on("start", dragstarted)
    .on("drag", dragged)
    .on("end", dragended);
}

function setData(data){
  console.log(data);


  simulation.nodes(data.nodes);
  forceLink.links(data.links);
  for(let type in linkTypes){
    linkTypes[type].selection=linkTypes[type].selection.data(data.links).join(linkTypes[type].type||"line");
    linkTypes[type].update(linkTypes[type].selection);
  }
  for(let type in nodeTypes){
    nodeTypes[type].selection=nodeTypes[type].selection
      .data(data.nodes,function(d){return d.id;}).join(nodeTypes[type].type||"circle");
    nodeTypes[type].update(nodeTypes[type].selection);
  }


  simulation.restart();
}


function initState(data){
  console.log(data)

  //dims:qudit dims,parties:parties(currently one qudit per party),state:state vector
  let n=data.dims.length;
  let parties=n;
  stateData=data;
  //test: show possible outcomes amplitudes along with their phase
  //meaning: for qubits, 0 is a dark circle or a dot at the center, 1 is a bright circle (or has an empty center to represent higher energy), for larger dimensions there can be more concentric circles and a larger outline for teh node. opacity and/or brightness or contrast is amplitude (alternatively probability/time length of the outcome is amplitude), color hue is phase (1 being red? i being yellow?), and maybe we can combine different possibilities in one oicture? liek say drawing all possibilities but at slightly different offsets from teh main nodes? in circles? in fractal patterns?
  possibleStates=[];
  function getQuditValues(index,dims){
    let result=[];
    for(let d of dims){
      result.unshift(index%d);
    }
    return result;
  }
  for(let [i,x] of data.state.entries()){
    let values=getQuditValues(i,data.dims);
    let prob=Math.sqrt(x.re*x.re+x.im*x.im);
    if(prob==0)continue;
    let obj={prob:prob,values:values,amplitude:x,phase:Math.atan(x.im/x.re)}
    possibleStates.push(obj);
  }
  function complex2str(x){
    let re=x.re.toString().substring(0,5),im=x.im.toString().substring(0,5);
    if(x.re!=0)
    {
      if(x.im!=0){return ""+re+"+"+im+"i";}
      else {return ""+re;}
    }
    else{
      if(x.im!=0){return im+"i";}
      else {return "0";}
    }
  }
  setTimeout(()=>{
    let text="";//data.name+" ";
    for(let [i,state] of possibleStates.entries()){
      text+=((i>0)?"+":"")+complex2str(state.amplitude)+"|"+state.values.join("")+"> ";
    }
    titleText.text(text);
  },10);

  if(data.steps){maxtimestep=data.steps;}
  else{maxtimestep=possibleStates*100;}
  timestep=0;time=0;
  let graph={nodes:[],links:[]};
  for(let i=0;i<n;i++){graph.nodes.push( {id:i,dim:data.dims[i],index:i,party:i})}
  for(let key in data.e_stats){
    let st=key.split(",").map((x)=>parseInt(x.trim()));
    let value=data.e_stats[key];
    graph.links.push({source:graph.nodes[st[0]],target:graph.nodes[st[1]],max:value.max,min:value.min});
  }
  /*for(let i=0;i<n;i++){
    for(let j=0;j<i;j++){
      graph.links.push({source:i,target:j});
    }
  }*/
  setData(graph);

}

d3.json("state.json").then(initState);


</script>

</head>

<body>




</body>


</html>
